// Code generated by rdfkit; DO NOT EDIT.
// 0e5d8aea0eab98a072d4a02faaee1ee914ec99eab2ca473429726faed4a13f69  https://www.w3.org/ns/shacl.ttl

package shacliri

import "github.com/dpb587/rdfkit-go/rdf"

// This vocabulary defines terms used in SHACL, the W3C Shapes Constraint Language.
const Base rdf.IRI = "http://www.w3.org/ns/shacl#"

const (
	// The base class of validation results, typically not instantiated directly.
	AbstractResult_Class = Base + "AbstractResult"

	// The (single) value of this property must be a list of path elements, representing the elements of alternative
	// paths.
	AlternativePath_Property = Base + "alternativePath"

	AndConstraintComponent_And_Parameter = Base + "AndConstraintComponent-and"

	// A constraint component that can be used to test whether a value node conforms to all members of a provided list of
	// shapes.
	AndConstraintComponent_ConstraintComponent = Base + "AndConstraintComponent"

	// RDF list of shapes to validate the value nodes against.
	And_Property = Base + "and"

	// The annotation property that shall be set.
	AnnotationProperty_Property = Base + "annotationProperty"

	// The (default) values of the annotation property.
	AnnotationValue_Property = Base + "annotationValue"

	// The name of the SPARQL variable from the SELECT clause that shall be used for the values.
	AnnotationVarName_Property = Base + "annotationVarName"

	// The SPARQL ASK query to execute.
	Ask_Property = Base + "ask"

	// The node kind of all blank nodes or IRIs.
	BlankNodeOrIRI_NodeKind = Base + "BlankNodeOrIRI"

	// The node kind of all blank nodes or literals.
	BlankNodeOrLiteral_NodeKind = Base + "BlankNodeOrLiteral"

	// The node kind of all blank nodes.
	BlankNode_NodeKind = Base + "BlankNode"

	ClassConstraintComponent_Class_Parameter = Base + "ClassConstraintComponent-class"

	// A constraint component that can be used to verify that each value node is an instance of a given type.
	ClassConstraintComponent_ConstraintComponent = Base + "ClassConstraintComponent"

	// The type that all value nodes must have.
	Class_Property = Base + "class"

	ClosedConstraintComponent_Closed_Parameter = Base + "ClosedConstraintComponent-closed"

	// A constraint component that can be used to indicate that focus nodes must only have values for those properties
	// that have been explicitly enumerated via sh:property/sh:path.
	ClosedConstraintComponent_ConstraintComponent = Base + "ClosedConstraintComponent"

	ClosedConstraintComponent_IgnoredProperties_Parameter = Base + "ClosedConstraintComponent-ignoredProperties"

	// If set to true then the shape is closed.
	Closed_Property = Base + "closed"

	// The shapes that the focus nodes need to conform to before a rule is executed on them.
	Condition_Property = Base + "condition"

	// True if the validation did not produce any validation results, and false otherwise.
	Conforms_Property = Base + "conforms"

	// The class of constraint components.
	ConstraintComponent_Class = Base + "ConstraintComponent"

	// The SPARQL CONSTRUCT query to execute.
	Construct_Property = Base + "construct"

	// A constraint component that can be used to restrict the datatype of all value nodes.
	DatatypeConstraintComponent_ConstraintComponent = Base + "DatatypeConstraintComponent"

	DatatypeConstraintComponent_Datatype_Parameter = Base + "DatatypeConstraintComponent-datatype"

	// Specifies an RDF datatype that all value nodes must have.
	Datatype_Property = Base + "datatype"

	// If set to true then all nodes conform to this.
	Deactivated_Property = Base + "deactivated"

	// Links a resource with its namespace prefix declarations.
	Declare_Property = Base + "declare"

	// A default value for a property, for example for user interface tools to pre-populate input fields.
	DefaultValue_Property = Base + "defaultValue"

	// Human-readable descriptions for the property in the context of the surrounding shape.
	Description_Property = Base + "description"

	// Links a result with other results that provide more details, for example to describe violations against nested
	// shapes.
	Detail_Property = Base + "detail"

	// A constraint component that can be used to verify that the set of value nodes is disjoint with the the set of nodes
	// that have the focus node as subject and the value of a given property as predicate.
	DisjointConstraintComponent_ConstraintComponent = Base + "DisjointConstraintComponent"

	DisjointConstraintComponent_Disjoint_Parameter = Base + "DisjointConstraintComponent-disjoint"

	// Specifies a property where the set of values must be disjoint with the value nodes.
	Disjoint_Property = Base + "disjoint"

	// An entailment regime that indicates what kind of inferencing is required by a shapes graph.
	Entailment_Property = Base + "entailment"

	// A constraint component that can be used to verify that the set of value nodes is equal to the set of nodes that
	// have the focus node as subject and the value of a given property as predicate.
	EqualsConstraintComponent_ConstraintComponent = Base + "EqualsConstraintComponent"

	EqualsConstraintComponent_Equals_Parameter = Base + "EqualsConstraintComponent-equals"

	// Specifies a property that must have the same values as the value nodes.
	Equals_Property = Base + "equals"

	// A constraint component that can be used to verify that a given node expression produces true for all value nodes.
	ExpressionConstraintComponent_ConstraintComponent = Base + "ExpressionConstraintComponent"

	ExpressionConstraintComponent_Expression_Parameter = Base + "ExpressionConstraintComponent-expression"

	// The node expression that must return true for the value nodes.
	Expression_Property = Base + "expression"

	// The shape that all input nodes of the expression need to conform to.
	FilterShape_Property = Base + "filterShape"

	// An optional flag to be used with regular expression pattern matching.
	Flags_Property = Base + "flags"

	// The focus node that was validated when the result was produced.
	FocusNode_Property = Base + "focusNode"

	// The class of SHACL functions.
	Function_Class = Base + "Function"

	// Can be used to link to a property group to indicate that a property shape belongs to a group of related property
	// shapes.
	Group_Property = Base + "group"

	// A constraint component that can be used to verify that one of the value nodes is a given RDF node.
	HasValueConstraintComponent_ConstraintComponent = Base + "HasValueConstraintComponent"

	HasValueConstraintComponent_HasValue_Parameter = Base + "HasValueConstraintComponent-hasValue"

	// Specifies a value that must be among the value nodes.
	HasValue_Property = Base + "hasValue"

	// The node kind of all IRIs or literals.
	IRIOrLiteral_NodeKind = Base + "IRIOrLiteral"

	// The node kind of all IRIs.
	IRI_NodeKind = Base + "IRI"

	// An optional RDF list of properties that are also permitted in addition to those explicitly enumerated via
	// sh:property/sh:path.
	IgnoredProperties_Property = Base + "ignoredProperties"

	// A constraint component that can be used to exclusively enumerate the permitted value nodes.
	InConstraintComponent_ConstraintComponent = Base + "InConstraintComponent"

	InConstraintComponent_In_Parameter = Base + "InConstraintComponent-in"

	// Specifies a list of allowed values so that each value node must be among the members of the given list.
	In_Property = Base + "in"

	// The severity for an informational validation result.
	Info_Severity = Base + "Info"

	// A list of node expressions that shall be intersected.
	Intersection_Property = Base + "intersection"

	// The (single) value of this property represents an inverse path (object to subject).
	InversePath_Property = Base + "inversePath"

	// A constraint component with the parameter sh:js linking to a sh:JSConstraint containing a sh:script.
	JSConstraintComponent_ConstraintComponent = Base + "JSConstraintComponent"

	// The class of constraints backed by a JavaScript function.
	JSConstraint_Class = Base + "JSConstraint"

	JSConstraint_Js_Parameter = Base + "JSConstraint-js"

	// Abstract base class of resources that declare an executable JavaScript.
	JSExecutable_Class = Base + "JSExecutable"

	// The class of SHACL functions that execute a JavaScript function when called.
	JSFunction_Class = Base + "JSFunction"

	// Represents a JavaScript library, typically identified by one or more URLs of files to include.
	JSLibrary_Class = Base + "JSLibrary"

	// The class of SHACL rules expressed using JavaScript.
	JSRule_Class = Base + "JSRule"

	// The (meta) class for parameterizable targets that are based on JavaScript functions.
	JSTargetType_Class = Base + "JSTargetType"

	// The class of targets that are based on JavaScript functions.
	JSTarget_Class = Base + "JSTarget"

	// A SHACL validator based on JavaScript. This can be used to declare SHACL constraint components that perform
	// JavaScript-based validation when used.
	JSValidator_Class = Base + "JSValidator"

	// The name of the JavaScript function to execute.
	JsFunctionName_Property = Base + "jsFunctionName"

	// Declares the URLs of a JavaScript library. This should be the absolute URL of a JavaScript file. Implementations
	// may redirect those to local files.
	JsLibraryURL_Property = Base + "jsLibraryURL"

	// Declares which JavaScript libraries are needed to execute this.
	JsLibrary_Property = Base + "jsLibrary"

	// Constraints expressed in JavaScript.
	Js_Property = Base + "js"

	// Outlines how human-readable labels of instances of the associated Parameterizable shall be produced. The values can
	// contain {?paramName} as placeholders for the actual values of the given parameter.
	LabelTemplate_Property = Base + "labelTemplate"

	// A constraint component that can be used to enumerate language tags that all value nodes must have.
	LanguageInConstraintComponent_ConstraintComponent = Base + "LanguageInConstraintComponent"

	LanguageInConstraintComponent_LanguageIn_Parameter = Base + "LanguageInConstraintComponent-languageIn"

	// Specifies a list of language tags that all value nodes must have.
	LanguageIn_Property = Base + "languageIn"

	// A constraint component that can be used to verify that each value node is smaller than all the nodes that have the
	// focus node as subject and the value of a given property as predicate.
	LessThanConstraintComponent_ConstraintComponent = Base + "LessThanConstraintComponent"

	LessThanConstraintComponent_LessThan_Parameter = Base + "LessThanConstraintComponent-lessThan"

	// A constraint component that can be used to verify that every value node is smaller than all the nodes that have the
	// focus node as subject and the value of a given property as predicate.
	LessThanOrEqualsConstraintComponent_ConstraintComponent = Base + "LessThanOrEqualsConstraintComponent"

	LessThanOrEqualsConstraintComponent_LessThanOrEquals_Parameter = Base + "LessThanOrEqualsConstraintComponent-lessThanOrEquals"

	// Specifies a property that must have smaller or equal values than the value nodes.
	LessThanOrEquals_Property = Base + "lessThanOrEquals"

	// Specifies a property that must have smaller values than the value nodes.
	LessThan_Property = Base + "lessThan"

	// The node kind of all literals.
	Literal_NodeKind = Base + "Literal"

	// A constraint component that can be used to restrict the maximum number of value nodes.
	MaxCountConstraintComponent_ConstraintComponent = Base + "MaxCountConstraintComponent"

	MaxCountConstraintComponent_MaxCount_Parameter = Base + "MaxCountConstraintComponent-maxCount"

	// Specifies the maximum number of values in the set of value nodes.
	MaxCount_Property = Base + "maxCount"

	// A constraint component that can be used to restrict the range of value nodes with a maximum exclusive value.
	MaxExclusiveConstraintComponent_ConstraintComponent = Base + "MaxExclusiveConstraintComponent"

	MaxExclusiveConstraintComponent_MaxExclusive_Parameter = Base + "MaxExclusiveConstraintComponent-maxExclusive"

	// Specifies the maximum exclusive value of each value node.
	MaxExclusive_Property = Base + "maxExclusive"

	// A constraint component that can be used to restrict the range of value nodes with a maximum inclusive value.
	MaxInclusiveConstraintComponent_ConstraintComponent = Base + "MaxInclusiveConstraintComponent"

	MaxInclusiveConstraintComponent_MaxInclusive_Parameter = Base + "MaxInclusiveConstraintComponent-maxInclusive"

	// Specifies the maximum inclusive value of each value node.
	MaxInclusive_Property = Base + "maxInclusive"

	// A constraint component that can be used to restrict the maximum string length of value nodes.
	MaxLengthConstraintComponent_ConstraintComponent = Base + "MaxLengthConstraintComponent"

	MaxLengthConstraintComponent_MaxLength_Parameter = Base + "MaxLengthConstraintComponent-maxLength"

	// Specifies the maximum string length of each value node.
	MaxLength_Property = Base + "maxLength"

	// A human-readable message (possibly with placeholders for variables) explaining the cause of the result.
	Message_Property = Base + "message"

	// A constraint component that can be used to restrict the minimum number of value nodes.
	MinCountConstraintComponent_ConstraintComponent = Base + "MinCountConstraintComponent"

	MinCountConstraintComponent_MinCount_Parameter = Base + "MinCountConstraintComponent-minCount"

	// Specifies the minimum number of values in the set of value nodes.
	MinCount_Property = Base + "minCount"

	// A constraint component that can be used to restrict the range of value nodes with a minimum exclusive value.
	MinExclusiveConstraintComponent_ConstraintComponent = Base + "MinExclusiveConstraintComponent"

	MinExclusiveConstraintComponent_MinExclusive_Parameter = Base + "MinExclusiveConstraintComponent-minExclusive"

	// Specifies the minimum exclusive value of each value node.
	MinExclusive_Property = Base + "minExclusive"

	// A constraint component that can be used to restrict the range of value nodes with a minimum inclusive value.
	MinInclusiveConstraintComponent_ConstraintComponent = Base + "MinInclusiveConstraintComponent"

	MinInclusiveConstraintComponent_MinInclusive_Parameter = Base + "MinInclusiveConstraintComponent-minInclusive"

	// Specifies the minimum inclusive value of each value node.
	MinInclusive_Property = Base + "minInclusive"

	// A constraint component that can be used to restrict the minimum string length of value nodes.
	MinLengthConstraintComponent_ConstraintComponent = Base + "MinLengthConstraintComponent"

	MinLengthConstraintComponent_MinLength_Parameter = Base + "MinLengthConstraintComponent-minLength"

	// Specifies the minimum string length of each value node.
	MinLength_Property = Base + "minLength"

	// Human-readable labels for the property in the context of the surrounding shape.
	Name_Property = Base + "name"

	// The namespace associated with a prefix in a prefix declaration.
	Namespace_Property = Base + "namespace"

	// A constraint component that can be used to verify that all value nodes conform to the given node shape.
	NodeConstraintComponent_ConstraintComponent = Base + "NodeConstraintComponent"

	NodeConstraintComponent_Node_Parameter = Base + "NodeConstraintComponent-node"

	// A constraint component that can be used to restrict the RDF node kind of each value node.
	NodeKindConstraintComponent_ConstraintComponent = Base + "NodeKindConstraintComponent"

	NodeKindConstraintComponent_NodeKind_Parameter = Base + "NodeKindConstraintComponent-nodeKind"

	// The class of all node kinds, including sh:BlankNode, sh:IRI, sh:Literal or the combinations of these:
	// sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral, sh:IRIOrLiteral.
	NodeKind_Class = Base + "NodeKind"

	// Specifies the node kind (e.g. IRI or literal) each value node.
	NodeKind_Property = Base + "nodeKind"

	// A node shape is a shape that specifies constraint that need to be met with respect to focus nodes.
	NodeShape_Class = Base + "NodeShape"

	// The validator(s) used to evaluate a constraint in the context of a node shape.
	NodeValidator_Property = Base + "nodeValidator"

	// Specifies the node shape that all value nodes must conform to.
	Node_Property = Base + "node"

	// The node expression producing the input nodes of a filter shape expression.
	Nodes_Property = Base + "nodes"

	// A constraint component that can be used to verify that value nodes do not conform to a given shape.
	NotConstraintComponent_ConstraintComponent = Base + "NotConstraintComponent"

	NotConstraintComponent_Not_Parameter = Base + "NotConstraintComponent-not"

	// Specifies a shape that the value nodes must not conform to.
	Not_Property = Base + "not"

	// An expression producing the nodes that shall be inferred as objects.
	Object_Property = Base + "object"

	// The (single) value of this property represents a path that is matched one or more times.
	OneOrMorePath_Property = Base + "oneOrMorePath"

	// Indicates whether a parameter is optional.
	Optional_Property = Base + "optional"

	// A constraint component that can be used to restrict the value nodes so that they conform to at least one out of
	// several provided shapes.
	OrConstraintComponent_ConstraintComponent = Base + "OrConstraintComponent"

	OrConstraintComponent_Or_Parameter = Base + "OrConstraintComponent-or"

	// Specifies a list of shapes so that the value nodes must conform to at least one of the shapes.
	Or_Property = Base + "or"

	// Specifies the relative order of this compared to its siblings. For example use 0 for the first, 1 for the second.
	Order_Property = Base + "order"

	// The class of parameter declarations, consisting of a path predicate and (possibly) information about allowed value
	// type, cardinality and other characteristics.
	Parameter_Class = Base + "Parameter"

	// The parameters of a function or constraint component.
	Parameter_Property = Base + "parameter"

	// Superclass of components that can take parameters, especially functions and constraint components.
	Parameterizable_Class = Base + "Parameterizable"

	// Specifies the property path of a property shape.
	Path_Property = Base + "path"

	// A constraint component that can be used to verify that every value node matches a given regular expression.
	PatternConstraintComponent_ConstraintComponent = Base + "PatternConstraintComponent"

	PatternConstraintComponent_Flags_Parameter   = Base + "PatternConstraintComponent-flags"
	PatternConstraintComponent_Pattern_Parameter = Base + "PatternConstraintComponent-pattern"

	// Specifies a regular expression pattern that the string representations of the value nodes must match.
	Pattern_Property = Base + "pattern"

	// An expression producing the properties that shall be inferred as predicates.
	Predicate_Property = Base + "predicate"

	// The class of prefix declarations, consisting of pairs of a prefix with a namespace.
	PrefixDeclaration_Class = Base + "PrefixDeclaration"

	// The prefix of a prefix declaration.
	Prefix_Property = Base + "prefix"

	// The prefixes that shall be applied before parsing the associated SPARQL query.
	Prefixes_Property = Base + "prefixes"

	// A constraint component that can be used to verify that all value nodes conform to the given property shape.
	PropertyConstraintComponent_ConstraintComponent = Base + "PropertyConstraintComponent"

	PropertyConstraintComponent_Property_Parameter = Base + "PropertyConstraintComponent-property"

	// Instances of this class represent groups of property shapes that belong together.
	PropertyGroup_Class = Base + "PropertyGroup"

	// A property shape is a shape that specifies constraints on the values of a focus node for a given property or path.
	PropertyShape_Class = Base + "PropertyShape"

	// The validator(s) used to evaluate a constraint in the context of a property shape.
	PropertyValidator_Property = Base + "propertyValidator"

	// Links a shape to its property shapes.
	Property_Property = Base + "property"

	// A constraint component that can be used to verify that a specified maximum number of value nodes conforms to a
	// given shape.
	QualifiedMaxCountConstraintComponent_ConstraintComponent = Base + "QualifiedMaxCountConstraintComponent"

	QualifiedMaxCountConstraintComponent_QualifiedMaxCount_Parameter            = Base + "QualifiedMaxCountConstraintComponent-qualifiedMaxCount"
	QualifiedMaxCountConstraintComponent_QualifiedValueShape_Parameter          = Base + "QualifiedMaxCountConstraintComponent-qualifiedValueShape"
	QualifiedMaxCountConstraintComponent_QualifiedValueShapesDisjoint_Parameter = Base + "QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint"

	// The maximum number of value nodes that can conform to the shape.
	QualifiedMaxCount_Property = Base + "qualifiedMaxCount"

	// A constraint component that can be used to verify that a specified minimum number of value nodes conforms to a
	// given shape.
	QualifiedMinCountConstraintComponent_ConstraintComponent = Base + "QualifiedMinCountConstraintComponent"

	QualifiedMinCountConstraintComponent_QualifiedMinCount_Parameter            = Base + "QualifiedMinCountConstraintComponent-qualifiedMinCount"
	QualifiedMinCountConstraintComponent_QualifiedValueShape_Parameter          = Base + "QualifiedMinCountConstraintComponent-qualifiedValueShape"
	QualifiedMinCountConstraintComponent_QualifiedValueShapesDisjoint_Parameter = Base + "QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint"

	// The minimum number of value nodes that must conform to the shape.
	QualifiedMinCount_Property = Base + "qualifiedMinCount"

	// The shape that a specified number of values must conform to.
	QualifiedValueShape_Property = Base + "qualifiedValueShape"

	// Can be used to mark the qualified value shape to be disjoint with its sibling shapes.
	QualifiedValueShapesDisjoint_Property = Base + "qualifiedValueShapesDisjoint"

	// A class of result annotations, which define the rules to derive the values of a given annotation property as extra
	// values for a validation result.
	ResultAnnotation_Class = Base + "ResultAnnotation"

	// Links a SPARQL validator with zero or more sh:ResultAnnotation instances, defining how to derive additional result
	// properties based on the variables of the SELECT query.
	ResultAnnotation_Property = Base + "resultAnnotation"

	// Human-readable messages explaining the cause of the result.
	ResultMessage_Property = Base + "resultMessage"

	// The path of a validation result, based on the path of the validated property shape.
	ResultPath_Property = Base + "resultPath"

	// The severity of the result, e.g. warning.
	ResultSeverity_Property = Base + "resultSeverity"

	// The validation results contained in a validation report.
	Result_Property = Base + "result"

	// The expected type of values returned by the associated function.
	ReturnType_Property = Base + "returnType"

	// The class of SHACL rules. Never instantiated directly.
	Rule_Class = Base + "Rule"

	// The rules linked to a shape.
	Rule_Property = Base + "rule"

	// The class of SPARQL executables that are based on an ASK query.
	SPARQLAskExecutable_Class = Base + "SPARQLAskExecutable"

	// The class of validators based on SPARQL ASK queries. The queries are evaluated for each value node and are supposed
	// to return true if the given node conforms.
	SPARQLAskValidator_Class = Base + "SPARQLAskValidator"

	// A constraint component that can be used to define constraints based on SPARQL queries.
	SPARQLConstraintComponent_ConstraintComponent = Base + "SPARQLConstraintComponent"

	SPARQLConstraintComponent_Sparql_Parameter = Base + "SPARQLConstraintComponent-sparql"

	// The class of constraints based on SPARQL SELECT queries.
	SPARQLConstraint_Class = Base + "SPARQLConstraint"

	// The class of SPARQL executables that are based on a CONSTRUCT query.
	SPARQLConstructExecutable_Class = Base + "SPARQLConstructExecutable"

	// The class of resources that encapsulate a SPARQL query.
	SPARQLExecutable_Class = Base + "SPARQLExecutable"

	// A function backed by a SPARQL query - either ASK or SELECT.
	SPARQLFunction_Class = Base + "SPARQLFunction"

	// The class of SHACL rules based on SPARQL CONSTRUCT queries.
	SPARQLRule_Class = Base + "SPARQLRule"

	// The class of SPARQL executables based on a SELECT query.
	SPARQLSelectExecutable_Class = Base + "SPARQLSelectExecutable"

	// The class of validators based on SPARQL SELECT queries. The queries are evaluated for each focus node and are
	// supposed to produce bindings for all focus nodes that do not conform.
	SPARQLSelectValidator_Class = Base + "SPARQLSelectValidator"

	// The (meta) class for parameterizable targets that are based on SPARQL queries.
	SPARQLTargetType_Class = Base + "SPARQLTargetType"

	// The class of targets that are based on SPARQL queries.
	SPARQLTarget_Class = Base + "SPARQLTarget"

	// The class of SPARQL executables based on a SPARQL UPDATE.
	SPARQLUpdateExecutable_Class = Base + "SPARQLUpdateExecutable"

	// The SPARQL SELECT query to execute.
	Select_Property = Base + "select"

	// The class of validation result severity levels, including violation and warning levels.
	Severity_Class = Base + "Severity"

	// Defines the severity that validation results produced by a shape must have. Defaults to sh:Violation.
	Severity_Property = Base + "severity"

	// A shape is a collection of constraints that may be targeted for certain nodes.
	Shape_Class = Base + "Shape"

	// If true then the validation engine was certain that the shapes graph has passed all SHACL syntax requirements
	// during the validation process.
	ShapesGraphWellFormed_Property = Base + "shapesGraphWellFormed"

	// Shapes graphs that should be used when validating this data graph.
	ShapesGraph_Property = Base + "shapesGraph"

	// The constraint component that is the source of the result.
	SourceConstraintComponent_Property = Base + "sourceConstraintComponent"

	// The constraint that was validated when the result was produced.
	SourceConstraint_Property = Base + "sourceConstraint"

	// The shape that is was validated when the result was produced.
	SourceShape_Property = Base + "sourceShape"

	// Links a shape with SPARQL constraints.
	Sparql_Property = Base + "sparql"

	// An expression producing the resources that shall be inferred as subjects.
	Subject_Property = Base + "subject"

	// Suggested shapes graphs for this ontology. The values of this property may be used in the absence of specific
	// sh:shapesGraph statements.
	SuggestedShapesGraph_Property = Base + "suggestedShapesGraph"

	// Links a shape to a class, indicating that all instances of the class must conform to the shape.
	TargetClass_Property = Base + "targetClass"

	// Links a shape to individual nodes, indicating that these nodes must conform to the shape.
	TargetNode_Property = Base + "targetNode"

	// Links a shape to a property, indicating that all all objects of triples that have the given property as their
	// predicate must conform to the shape.
	TargetObjectsOf_Property = Base + "targetObjectsOf"

	// Links a shape to a property, indicating that all subjects of triples that have the given property as their
	// predicate must conform to the shape.
	TargetSubjectsOf_Property = Base + "targetSubjectsOf"

	// The (meta) class for parameterizable targets. Instances of this are instantiated as values of the sh:target
	// property.
	TargetType_Class = Base + "TargetType"

	// The base class of targets such as those based on SPARQL queries.
	Target_Class = Base + "Target"

	// Links a shape to a target specified by an extension language, for example instances of sh:SPARQLTarget.
	Target_Property = Base + "target"

	// A node expression that represents the current focus node.
	This_Resource = Base + "this"

	TripleRule_Class = Base + "TripleRule"

	// A list of node expressions that shall be used together.
	Union_Property = Base + "union"

	// A constraint component that can be used to specify that no pair of value nodes may use the same language tag.
	UniqueLangConstraintComponent_ConstraintComponent = Base + "UniqueLangConstraintComponent"

	UniqueLangConstraintComponent_UniqueLang_Parameter = Base + "UniqueLangConstraintComponent-uniqueLang"

	// Specifies whether all node values must have a unique (or no) language tag.
	UniqueLang_Property = Base + "uniqueLang"

	// The SPARQL UPDATE to execute.
	Update_Property = Base + "update"

	// The class of SHACL validation reports.
	ValidationReport_Class = Base + "ValidationReport"

	// The class of validation results.
	ValidationResult_Class = Base + "ValidationResult"

	// The class of validators, which provide instructions on how to process a constraint definition. This class serves as
	// base class for the SPARQL-based validators and other possible implementations.
	Validator_Class = Base + "Validator"

	// The validator(s) used to evaluate constraints of either node or property shapes.
	Validator_Property = Base + "validator"

	// An RDF node that has caused the result.
	Value_Property = Base + "value"

	// The severity for a violation validation result.
	Violation_Severity = Base + "Violation"

	// The severity for a warning validation result.
	Warning_Severity = Base + "Warning"

	// A constraint component that can be used to restrict the value nodes so that they conform to exactly one out of
	// several provided shapes.
	XoneConstraintComponent_ConstraintComponent = Base + "XoneConstraintComponent"

	XoneConstraintComponent_Xone_Parameter = Base + "XoneConstraintComponent-xone"

	// Specifies a list of shapes so that the value nodes must conform to exactly one of the shapes.
	Xone_Property = Base + "xone"

	// The (single) value of this property represents a path that is matched zero or more times.
	ZeroOrMorePath_Property = Base + "zeroOrMorePath"

	// The (single) value of this property represents a path that is matched zero or one times.
	ZeroOrOnePath_Property = Base + "zeroOrOnePath"
)
