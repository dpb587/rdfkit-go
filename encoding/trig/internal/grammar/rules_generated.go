// Code generated by rulegencmd; DO NOT EDIT.

package grammar

import "fmt"

type R uint

const (
	// R_trigDoc ::= ( directive | block )*
	R_trigDoc R = iota

	// R_block ::= triplesOrGraph | wrappedGraph | triples2 | ( 'GRAPH' labelOrSubject wrappedGraph )
	R_block

	// R_triplesOrGraph ::= labelOrSubject ( wrappedGraph | ( predicateObjectList '.' ) )
	R_triplesOrGraph

	// R_triples2 ::= ( blankNodePropertyList predicateObjectList? '.' ) | ( collection predicateObjectList '.' )
	R_triples2

	// R_wrappedGraph ::= '{' triplesBlock? '}'
	R_wrappedGraph

	// R_triplesBlock ::= triples ( ( '.' triplesBlock? )? )
	R_triplesBlock

	// R_labelOrSubject ::= iri | BlankNode
	R_labelOrSubject

	// R_directive ::= prefixID | base | sparqlPrefix | sparqlBase
	R_directive

	// R_prefixID ::= '@prefix' PNAME_NS IRIREF '.'
	R_prefixID

	// R_base ::= '@base' IRIREF '.'
	R_base

	// R_sparqlPrefix ::= 'PREFIX' PNAME_NS IRIREF
	R_sparqlPrefix

	// R_sparqlBase ::= 'BASE' IRIREF
	R_sparqlBase

	// R_triples ::= ( subject predicateObjectList ) | ( blankNodePropertyList predicateObjectList? )
	R_triples

	// R_predicateObjectList ::= verb objectList ( ( ';' ( ( verb objectList )? ) )* )
	R_predicateObjectList

	// R_objectList ::= object ( ( ',' object )* )
	R_objectList

	// R_verb ::= predicate | 'a'
	R_verb

	// R_subject ::= iri | blank
	R_subject

	// R_predicate ::= iri
	R_predicate

	// R_object ::= iri | blank | blankNodePropertyList | literal
	R_object

	// R_literal ::= RDFLiteral | NumericLiteral | BooleanLiteral
	R_literal

	// R_blank ::= BlankNode | collection
	R_blank

	// R_blankNodePropertyList ::= '[' predicateObjectList ']'
	R_blankNodePropertyList

	// R_collection ::= '(' object* ')'
	R_collection

	// R_NumericLiteral ::= INTEGER | DECIMAL | DOUBLE
	R_NumericLiteral

	// R_RDFLiteral ::= String ( ( LANGTAG | ( '^^' iri ) )? )
	R_RDFLiteral

	// R_BooleanLiteral ::= 'true' | 'false'
	R_BooleanLiteral

	// R_String ::= STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE | STRING_LITERAL_LONG_SINGLE_QUOTE | STRING_LITERAL_LONG_QUOTE
	R_String

	// R_iri ::= IRIREF | PrefixedName
	R_iri

	// R_PrefixedName ::= PNAME_LN | PNAME_NS
	R_PrefixedName

	// R_BlankNode ::= BLANK_NODE_LABEL | 'ANON'
	R_BlankNode

	// R_IRIREF ::= '<' ( ( [^#x0-#x20<>"{}|^`\] | UCHAR )* ) '>'
	R_IRIREF

	// R_PNAME_NS ::= PN_PREFIX? ':'
	R_PNAME_NS

	// R_PNAME_LN ::= PNAME_NS PN_LOCAL
	R_PNAME_LN

	// R_BLANK_NODE_LABEL ::= '_:' ( PN_CHARS_U | [0-9] ) ( ( ( ( PN_CHARS | '.' )* ) PN_CHARS )? )
	R_BLANK_NODE_LABEL

	// R_LANGTAG ::= '@' ( ( [a-z] | [A-Z] )+ ) ( ( '-' ( ( [a-z] | [A-Z] | [0-9] )+ ) )* )
	R_LANGTAG

	// R_INTEGER ::= ( ( '+' | '-' )? ) [0-9]+
	R_INTEGER

	// R_DECIMAL ::= ( ( '+' | '-' )? ) ( [0-9]* '.' [0-9]+ )
	R_DECIMAL

	// R_DOUBLE ::= ( ( '+' | '-' )? ) ( ( [0-9]+ '.' [0-9]* EXPONENT ) | ( '.' [0-9]+ EXPONENT ) | ( [0-9]+ EXPONENT ) )
	R_DOUBLE

	// R_EXPONENT ::= ( 'e' | 'E' ) ( ( '+' | '-' )? ) [0-9]+
	R_EXPONENT

	// R_STRING_LITERAL_QUOTE ::= '"' ( ( [^"\#xa#xd] | ECHAR | UCHAR )* ) '"'
	R_STRING_LITERAL_QUOTE

	// R_STRING_LITERAL_SINGLE_QUOTE ::= "'" ( ( [^'\#xa#xd] | ECHAR | UCHAR )* ) "'"
	R_STRING_LITERAL_SINGLE_QUOTE

	// R_STRING_LITERAL_LONG_SINGLE_QUOTE ::= "'''" ( ( ( ( "'" | "''" )? ) ( [^'\] | ECHAR | UCHAR ) )* ) "'''"
	R_STRING_LITERAL_LONG_SINGLE_QUOTE

	// R_STRING_LITERAL_LONG_QUOTE ::= '"""' ( ( ( ( '"' | '""' )? ) ( [^"\] | ECHAR | UCHAR ) )* ) '"""'
	R_STRING_LITERAL_LONG_QUOTE

	// R_UCHAR ::= ( '\u' HEX HEX HEX HEX ) | ( '\U' HEX HEX HEX HEX HEX HEX HEX HEX )
	R_UCHAR

	// R_ECHAR ::= '\' | ( 't' | 'b' | 'n' | 'r' | 'f' | '"' | "'" | '\' )
	R_ECHAR

	// R_NIL ::= '(' WS* ')'
	R_NIL

	// R_WS ::= ' ' | #x9 | #xd | #xa
	R_WS

	// R_ANON ::= '[' WS* ']'
	R_ANON

	// R_PN_CHARS_BASE ::= [A-Z] | [a-z] | [#xc0-#xd6] | [#xd8-#xf6] | [#xf8-#x2ff] | [#x370-#x37d] | [#x37f-#x1fff] | [#x200c-#x200d] | [#x2070-#x218f] | [#x2c00-#x2fef] | [#x3001-#xd7ff] | [#xf900-#xfdcf] | [#xfdf0-#xfffd] | [#x10000-#xeffff]
	R_PN_CHARS_BASE

	// R_PN_CHARS_U ::= PN_CHARS_BASE | '_'
	R_PN_CHARS_U

	// R_PN_CHARS ::= PN_CHARS_U | '-' | [0-9] | #xb7 | [#x300-#x36f] | [#x203f-#x2040]
	R_PN_CHARS

	// R_PN_PREFIX ::= PN_CHARS_BASE ( ( ( ( PN_CHARS | '.' )* ) PN_CHARS )? )
	R_PN_PREFIX

	// R_PN_LOCAL ::= ( PN_CHARS_U | ':' | [0-9] | PLX ) ( ( ( ( PN_CHARS | '.' | ':' | PLX )* ) ( PN_CHARS | ':' | PLX ) )? )
	R_PN_LOCAL

	// R_PLX ::= PERCENT | PN_LOCAL_ESC
	R_PLX

	// R_PERCENT ::= '%' HEX HEX
	R_PERCENT

	// R_HEX ::= [0-9] | [A-F] | [a-f]
	R_HEX

	// R_PN_LOCAL_ESC ::= '\' ( '_' | '~' | '.' | '-' | '!' | '$' | '&' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%' )
	R_PN_LOCAL_ESC
)

func (r R) String() string {
	switch r {
	case R_trigDoc:
		return "trigDoc"
	case R_block:
		return "block"
	case R_triplesOrGraph:
		return "triplesOrGraph"
	case R_triples2:
		return "triples2"
	case R_wrappedGraph:
		return "wrappedGraph"
	case R_triplesBlock:
		return "triplesBlock"
	case R_labelOrSubject:
		return "labelOrSubject"
	case R_directive:
		return "directive"
	case R_prefixID:
		return "prefixID"
	case R_base:
		return "base"
	case R_sparqlPrefix:
		return "sparqlPrefix"
	case R_sparqlBase:
		return "sparqlBase"
	case R_triples:
		return "triples"
	case R_predicateObjectList:
		return "predicateObjectList"
	case R_objectList:
		return "objectList"
	case R_verb:
		return "verb"
	case R_subject:
		return "subject"
	case R_predicate:
		return "predicate"
	case R_object:
		return "object"
	case R_literal:
		return "literal"
	case R_blank:
		return "blank"
	case R_blankNodePropertyList:
		return "blankNodePropertyList"
	case R_collection:
		return "collection"
	case R_NumericLiteral:
		return "NumericLiteral"
	case R_RDFLiteral:
		return "RDFLiteral"
	case R_BooleanLiteral:
		return "BooleanLiteral"
	case R_String:
		return "String"
	case R_iri:
		return "iri"
	case R_PrefixedName:
		return "PrefixedName"
	case R_BlankNode:
		return "BlankNode"
	case R_IRIREF:
		return "IRIREF"
	case R_PNAME_NS:
		return "PNAME_NS"
	case R_PNAME_LN:
		return "PNAME_LN"
	case R_BLANK_NODE_LABEL:
		return "BLANK_NODE_LABEL"
	case R_LANGTAG:
		return "LANGTAG"
	case R_INTEGER:
		return "INTEGER"
	case R_DECIMAL:
		return "DECIMAL"
	case R_DOUBLE:
		return "DOUBLE"
	case R_EXPONENT:
		return "EXPONENT"
	case R_STRING_LITERAL_QUOTE:
		return "STRING_LITERAL_QUOTE"
	case R_STRING_LITERAL_SINGLE_QUOTE:
		return "STRING_LITERAL_SINGLE_QUOTE"
	case R_STRING_LITERAL_LONG_SINGLE_QUOTE:
		return "STRING_LITERAL_LONG_SINGLE_QUOTE"
	case R_STRING_LITERAL_LONG_QUOTE:
		return "STRING_LITERAL_LONG_QUOTE"
	case R_UCHAR:
		return "UCHAR"
	case R_ECHAR:
		return "ECHAR"
	case R_NIL:
		return "NIL"
	case R_WS:
		return "WS"
	case R_ANON:
		return "ANON"
	case R_PN_CHARS_BASE:
		return "PN_CHARS_BASE"
	case R_PN_CHARS_U:
		return "PN_CHARS_U"
	case R_PN_CHARS:
		return "PN_CHARS"
	case R_PN_PREFIX:
		return "PN_PREFIX"
	case R_PN_LOCAL:
		return "PN_LOCAL"
	case R_PLX:
		return "PLX"
	case R_PERCENT:
		return "PERCENT"
	case R_HEX:
		return "HEX"
	case R_PN_LOCAL_ESC:
		return "PN_LOCAL_ESC"
	}

	return fmt.Sprintf("grammar.R(%d)", r)
}
