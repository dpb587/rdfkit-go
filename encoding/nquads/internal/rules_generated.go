// Code generated by rulegencmd; DO NOT EDIT.

package internal

// import "fmt"

// type R uint

// const (
// 	// R_nquadsDoc ::= statement? ( ( EOL statement )* ) EOL?
// 	R_nquadsDoc R = iota

// 	// R_statement ::= subject predicate object graphLabel? '.'
// 	R_statement

// 	// R_subject ::= IRIREF | BLANK_NODE_LABEL
// 	R_subject

// 	// R_predicate ::= IRIREF
// 	R_predicate

// 	// R_object ::= IRIREF | BLANK_NODE_LABEL | literal
// 	R_object

// 	// R_graphLabel ::= IRIREF | BLANK_NODE_LABEL
// 	R_graphLabel

// 	// R_literal ::= STRING_LITERAL_QUOTE ( ( ( '^^' IRIREF ) | LANGTAG )? )
// 	R_literal

// 	// R_LANGTAG ::= '@' ( ( [a-z] | [A-Z] )+ ) ( ( '-' ( ( [a-z] | [A-Z] | [0-9] )+ ) )* )
// 	R_LANGTAG

// 	// R_EOL ::= ( #xd | #xa )+
// 	R_EOL

// 	// R_IRIREF ::= '<' ( ( [^#x0-#x20<>"{}|^`\] | UCHAR )* ) '>'
// 	R_IRIREF

// 	// R_STRING_LITERAL_QUOTE ::= '"' ( ( [^"\#xa#xd] | ECHAR | UCHAR )* ) '"'
// 	R_STRING_LITERAL_QUOTE

// 	// R_BLANK_NODE_LABEL ::= '_:' ( PN_CHARS_U | [0-9] ) ( ( ( ( PN_CHARS | '.' )* ) PN_CHARS )? )
// 	R_BLANK_NODE_LABEL

// 	// R_UCHAR ::= ( '\u' HEX HEX HEX HEX ) | ( '\U' HEX HEX HEX HEX HEX HEX HEX HEX )
// 	R_UCHAR

// 	// R_ECHAR ::= '\' ( 't' | 'b' | 'n' | 'r' | 'f' | '"' | "'" | '\' )
// 	R_ECHAR

// 	// R_PN_CHARS_BASE ::= [A-Z] | [a-z] | [#xc0-#xd6] | [#xd8-#xf6] | [#xf8-#x2ff] | [#x370-#x37d] | [#x37f-#x1fff] | [#x200c-#x200d] | [#x2070-#x218f] | [#x2c00-#x2fef] | [#x3001-#xd7ff] | [#xf900-#xfdcf] | [#xfdf0-#xfffd] | [#x10000-#xeffff]
// 	R_PN_CHARS_BASE

// 	// R_PN_CHARS_U ::= PN_CHARS_BASE | '_' | ':'
// 	R_PN_CHARS_U

// 	// R_PN_CHARS ::= PN_CHARS_U | '-' | [0-9] | #xb7 | [#x300-#x36f] | [#x203f-#x2040]
// 	R_PN_CHARS

// 	// R_HEX ::= [0-9] | [A-F] | [a-f]
// 	R_HEX
// )

// func (r R) String() string {
// 	switch r {
// 	case R_nquadsDoc:
// 		return "nquadsDoc"
// 	case R_statement:
// 		return "statement"
// 	case R_subject:
// 		return "subject"
// 	case R_predicate:
// 		return "predicate"
// 	case R_object:
// 		return "object"
// 	case R_graphLabel:
// 		return "graphLabel"
// 	case R_literal:
// 		return "literal"
// 	case R_LANGTAG:
// 		return "LANGTAG"
// 	case R_EOL:
// 		return "EOL"
// 	case R_IRIREF:
// 		return "IRIREF"
// 	case R_STRING_LITERAL_QUOTE:
// 		return "STRING_LITERAL_QUOTE"
// 	case R_BLANK_NODE_LABEL:
// 		return "BLANK_NODE_LABEL"
// 	case R_UCHAR:
// 		return "UCHAR"
// 	case R_ECHAR:
// 		return "ECHAR"
// 	case R_PN_CHARS_BASE:
// 		return "PN_CHARS_BASE"
// 	case R_PN_CHARS_U:
// 		return "PN_CHARS_U"
// 	case R_PN_CHARS:
// 		return "PN_CHARS"
// 	case R_HEX:
// 		return "HEX"
// 	}

// 	return fmt.Sprintf("grammar.R(%d)", r)
// }
